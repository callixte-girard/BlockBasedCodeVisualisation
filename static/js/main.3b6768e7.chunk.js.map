{"version":3,"sources":["static/constants.js","components/containers/CodeContainer.js","components/containers/BlocklyContainer.js","components/parse/BlockLogic.js","components/parse/EsprimaToXml.js","components/parse/MainLogic.js","components/containers/MainContainer.js","App.js","serviceWorker.js","index.js"],"names":["line","star","style_dark","height","width","font","display","CodeContainer","props","exampleCode","style","placeholder","this","onChange","updateCode","React","Component","BlocklyContainer","xml_str","Blockly","getMainWorkspace","clear","Xml","appendDomToWorkspace","textToDom","prevProps","prevState","snapshot","updateBlocksFromXml","xmlContent","id","BlockLogic","varName","value","children","blockVarName","name","undefined","type","update","conditions","instructions","nb_elseif","length","nb_else","push","elseif","else","i","blockCondition","blockInstructions","concat","condition","from","to","by","arg","js_op","blocklyType","blockly1ArgExpressionTypeFromJsOp","console","log","left","right","blocklyOp","blocklyOpFromJsOp","blockly2ArgsExpressionTypeFromJsOp","exprType","fieldName","fieldTag","toString","EsprimaToXml","statements","xml_statements","statement","statementType","includes","blockStatement","blockRight","expression","expressionType","expressionOperator","variableName","variableValue","parseExpression","forVariableDeclaration","updateBy","parseUpdateStatement","parseIfStatement","parseWhileStatement","parseForStatement","declarations","declaration","blockDeclaration","blockVarValue","MainLogic","nextifyXmlStatementListIntoSingleBlock","operator","blockUpdate","forEndExpression","forVariableUpdate","statementCondition","statementInstructions","parseAutonomousStatementInstructions","forWhileStatement","blocksConditions","blocksInstructions","statementConsequent","statementAlternate","alternateCondition","alternateInstructions","forIfStatement","varInit","varTest","varUpdate","statementInit","statementTest","statementUpdate","operatorTest","blockFrom","blockTo","blockBy","forForStatement","parseListStatements","parseHostExpression","parseEndExpression","hostExpression","xml_expression","expressionArg","blockArg","for1ArgExpression","expressionArgLeft","expressionArgRight","blockArgLeft","blockArgRight","for2ArgsExpression","endExpression","endExpression_val","attrName_valueOrName","endExpression_type","jsx_cur","jsx_prev","blockChildren","parsedContent","xml_main","xmlns","jsx2str","esprima","require","MainContainer","state","bind","event","inputContent","target","syntaxicAnalysis","xmlContent_jsx","generateBlocksFromParsedContent","xmlContent_str","ReactDOMServer","renderToStaticMarkup","setState","ex","codeRaw","parse","body","tokenize","App","inject","toolbox","document","getElementById","className","Boolean","window","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.3b6768e7.chunk.js","sourcesContent":["export const line = \"--------------------------------------------------------------------------\"\nexport const star = \"***************************************************************************\"\n\n\nexport const style_dark = { // avoid killing your eyes !\n    \n    height: 500,\n    width: 500,\n\n    // color: \"#e7e0e0\",\n    // background: \"#1a1818\",\n    font: \"comic-sans-ms\",\n\n    // border: \"1px solid black\",\n    display: 'inline-block',\n    // padding: 40\n}","import React from 'react';\r\n\r\nimport {style_dark} from '../../static/constants';\r\n\r\n\r\nexport class CodeContainer extends React.Component {\r\n\r\n    constructor(props) {\r\n        super(props);\r\n\r\n        this.exampleCode = \"put your js code here...\"\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <textarea\r\n                style={style_dark}\r\n                // rows and cols don't work if they're overridden by height and width (in style_dark)\r\n                // rows=\"38\"\r\n                // cols=\"80\"\r\n                placeholder={this.exampleCode}\r\n                onChange={this.props.updateCode}\r\n            ></textarea>\r\n        );\r\n    }\r\n\r\n}","import React from 'react';\nimport Blockly from \"blockly\";\n\nimport {style_dark} from '../../static/constants';\n\n\nexport class BlocklyContainer extends React.Component {\n\n\n    updateBlocksFromXml(xml_str) {\n        Blockly.getMainWorkspace().clear();\n\n        try {\n            Blockly.Xml.appendDomToWorkspace(\n                Blockly.Xml.textToDom(\n                    xml_str\n                    // jsx2str(xml_str) // SHOULD NOT BE USED, must be converted before\n                ),\n                Blockly.getMainWorkspace()\n            );\n        } catch {}\n    }\n\n    componentWillUpdate(prevProps, prevState, snapshot) {\n        this.updateBlocksFromXml(prevProps.xmlContent);\n    }\n\n    render() {\n        return (\n            <div id=\"blocklyDiv\"\n                style={style_dark} // why don't you fucking work with colors ???\n            ></div>\n        );\n    }\n\n}","import React from 'react';\n\n\nexport class BlockLogic extends React.Component {\n\n\n    static forVariableDeclaration(varName, value) {\n        let children, blockVarName, blockValue;\n\n        blockVarName = <field name=\"VAR\">{varName}</field>;\n\n        if (value !== undefined) {\n            blockValue = <value name=\"VALUE\">{value}</value>;\n            children = [ blockVarName, blockValue ];\n        } else {\n            children = [ blockVarName ];\n        }\n\n        return <block type=\"variables_set\">\n            {children}\n        </block>\n    }\n\n    static forVariableUpdate(varName, update) {\n        return <block type=\"math_change\">\n            <field name=\"VAR\">\n                {varName}\n            </field>\n\n            <value name=\"DELTA\">\n                {update}\n            </value>\n        </block>\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n    static forIfStatement(conditions, instructions) {\n        let children = [];\n\n        // calculate and add mutation tag\n        const nb_elseif = conditions.length - 1;\n        const nb_else = instructions.length - conditions.length;\n        children.push(\n            <mutation\n                elseif={nb_elseif}\n                else={nb_else}\n            ></mutation>\n        );\n\n        // analyse conditions and associated instructions\n        for (let i=0 ; i < conditions.length ; i++) {\n            const blockCondition = conditions[i];\n            const blockInstructions = instructions[i];\n\n            children = children.concat([\n                <value name={\"IF\" + i}>{blockCondition}</value>,\n                <statement name={\"DO\" + i}>{blockInstructions}</statement>\n            ])\n        }\n\n        // try to analyse last else statement\n        try {\n            children.push(\n                <statement name=\"ELSE\">\n                    {instructions[conditions.length]}\n                </statement>\n            );\n        } catch {}\n\n        return <block type=\"controls_if\">{children}</block>\n    }\n\n    static forWhileStatement(condition, instructions) {\n        return <block type=\"controls_whileUntil\">\n            <field name=\"MODE\">\n                WHILE\n                {/*UNTIL*/}\n            </field>\n\n            <value name=\"BOOL\">\n                {condition}\n            </value>\n\n            <statement name=\"DO\">\n                {instructions}\n            </statement>\n        </block>\n    }\n\n    static forForStatement(varName, from, to, by, instructions) {\n        return <block type=\"controls_for\">\n            <field name=\"VAR\">\n                {varName}\n            </field>\n\n            <value name=\"FROM\">\n                {from}\n            </value>\n\n            <value name=\"TO\">\n                {to}\n            </value>\n\n            <value name=\"BY\">\n                {by}\n            </value>\n\n            <statement name=\"DO\">\n                {instructions}\n            </statement>\n        </block>\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n    static for1ArgExpression(arg, js_op) {\n        let blocklyType;\n\n        blocklyType = blockly1ArgExpressionTypeFromJsOp[js_op];\n        console.log(\"blocklyType:\", blocklyType);\n\n        return <block type={blocklyType}>\n            <value name=\"BOOL\">\n                {arg}\n            </value>\n        </block>\n    }\n\n    static for2ArgsExpression(left, right, js_op) {\n        let blocklyType, blocklyOp;\n\n        blocklyOp = blocklyOpFromJsOp[js_op];\n        blocklyType = blockly2ArgsExpressionTypeFromJsOp[js_op];\n        console.log(\"blocklyOp:\", blocklyOp);\n        console.log(\"blocklyType:\", blocklyType);\n\n        if (js_op === \"=\") {\n            return <block type={blocklyType}></block>\n        } else {\n            return <block type={blocklyType}>\n                <value name=\"A\">\n                    {left}\n                </value>\n\n                <value name=\"B\">\n                    {right}\n                </value>\n\n                <field name=\"OP\">\n                    {blocklyOp}\n                </field>\n            </block>\n        }\n\n    }\n\n\n    static forEndExpression(exprType, value) {\n        let blocklyType, fieldName;\n\n        if (exprType === 'Identifier') {\n            blocklyType = 'variables_get';\n            fieldName = 'VAR';\n        } else if (exprType === 'Literal') {\n            if (value === null) blocklyType = 'logic_null'; // fieldName is null here\n            else {\n                switch (typeof value) {\n                    case 'number':\n                        blocklyType = 'math_number';\n                        fieldName = 'NUM';\n                        break ;\n                    case 'string':\n                        blocklyType = 'text';\n                        fieldName = 'TEXT';\n                        break ;\n                    case 'boolean':\n                        blocklyType = 'logic_boolean';\n                        fieldName = 'BOOL';\n                        break ;\n                    default :\n                    // case 'undefined':\n                    //     blocklyType = 'logic_null';\n                    //     break ;\n                }\n            }\n        }\n\n        let fieldTag = \"\";\n        if (fieldName !== null)\n            fieldTag = // the .toString is IMPORTANT and must STAY EXACTLY HERE\n                <field name={fieldName}>\n                    {value.toString()}\n                </field>;\n\n        return <block type={blocklyType}>\n            {fieldTag}\n        </block>\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n\nconst blocklyOpFromJsOp = {\n    // logic_compare\n    \"===\" : \"EQ\", // added by C\n    \"==\" : \"EQ\",\n    \"!==\" : \"NEQ\", // added by C\n    \"!=\" : \"NEQ\",\n    \"<\" : \"LT\",\n    \"<=\" : \"LTE\",\n    \">\" : \"GT\",\n    \">=\" : \"GTE\",\n    // math_arithmetic\n    \"+\" : \"ADD\",\n    \"-\" : \"MINUS\",\n    \"*\" : \"MULTIPLY\",\n    \"/\" : \"DIVIDE\",\n    \"**\" : \"POWER\",\n    // logic_operation\n    \"&&\" : \"AND\",\n    \"||\" : \"OR\",\n};\n\nconst blockly1ArgExpressionTypeFromJsOp = {\n    // logic_negate\n    \"!\" : \"logic_negate\",\n    // math_negate\n    // to be added later... ;)\n};\n\nconst blockly2ArgsExpressionTypeFromJsOp = {\n    // logic_compare\n    \"===\" : \"logic_compare\", // added by C\n    \"==\" : \"logic_compare\",\n    \"!==\" : \"logic_compare\", // added by C\n    \"!=\" : \"logic_compare\",\n    \"<\" : \"logic_compare\",\n    \"<=\" : \"logic_compare\",\n    \">\" : \"logic_compare\",\n    \">=\" : \"logic_compare\",\n    // math_arithmetic\n    \"+\" : \"math_arithmetic\",\n    \"-\" : \"math_arithmetic\",\n    \"*\" : \"math_arithmetic\",\n    \"/\" : \"math_arithmetic\",\n    \"**\" : \"math_arithmetic\",\n    // logic_operation\n    \"&&\" : \"logic_operation\",\n    \"||\" : \"logic_operation\",\n};\n","import React from 'react';\n\nimport {BlockLogic} from \"./BlockLogic\";\nimport {MainLogic} from \"./MainLogic\";\n\nimport {splitLineByLine} from \"../../static/methods\";\nimport {line, star} from \"../../static/constants\";\n\n\nexport class EsprimaToXml extends React.Component {\n\n\n    static parseListStatements(statements) {\n        let xml_statements = [];\n\n        for (let i=0 ; i < statements.length ; i++)\n        {\n            const statement = statements[i];\n            const statementType = statement['type'];\n\n            // ### I - STATEMENTS\n            if (statementType.includes('Statement')) { // this excludes ExpressionStatements.\n                console.log(\"statementType:\", statementType);\n\n                let blockStatement, blockRight;\n                // ## I - a) EXPRESSION STATEMENTS\n                if (statementType === 'ExpressionStatement') {\n                    const expression = statement['expression'];\n                    const expressionType = expression['type'];\n                    const expressionOperator = expression['operator'];\n\n                    if (expressionType === 'AssignmentExpression') { // can have \"=\" or '-=' or '+='\n                        const variableName = expression['left']; // is a Literal\n                        const variableValue = expression['right']; // is an Expression too\n                        // console.log(\"variableName\" + i.toString() + \":\", variableName);\n                        // console.log(\"variableValue\" + i.toString() + \":\", variableValue);\n\n                        // get variable name\n                        const varName = variableName['name'];\n                        // get right part\n                        if (expressionOperator === '=') {\n                            blockRight = this.parseExpression(variableValue);\n                            blockStatement = BlockLogic.forVariableDeclaration(varName, blockRight);\n\n                        } else if (expressionOperator === '+=' || expressionOperator === '-=') {\n                            // determines updateValue\n                            let updateBy = variableValue['value'];\n                            blockStatement = this.parseUpdateStatement(varName, updateBy, expressionOperator);\n                        }\n\n                    } else if (expressionType === 'UpdateExpression') { // can have '--' or '++'\n                        const variableName = expression['argument'];\n                        // console.log(\"variableName\" + i.toString() + \":\", variableName);\n\n                        // get variable name\n                        const varName = variableName['name'];\n\n                        // determines updateValue\n                        let updateBy = 1 ;\n                        if (expressionOperator.includes(\"-\")) updateBy = -updateBy; // corresponds to '--'\n\n                        blockStatement = this.parseUpdateStatement(varName, updateBy, expressionOperator);\n                    }\n                } // ## I - b) IF, FOR, WHILE STATEMENTS\n                else {\n                    if (statementType === 'IfStatement')\n                        blockStatement = this.parseIfStatement(statement);\n                    else if (statementType === 'WhileStatement')\n                        blockStatement = this.parseWhileStatement(statement);\n                    else if (statementType === 'ForStatement')\n                        blockStatement = this.parseForStatement(statement);\n                }\n                // insert statement\n                xml_statements.push(blockStatement);\n\n            // ### II - DECLARATIONS\n            } else if (statementType.includes('Declaration')) {\n\n                if (statementType === 'VariableDeclaration') {\n                    const declarations = statement['declarations'];\n\n                    for (let i = 0; i < declarations.length; i++)\n                    {\n                        const declaration = declarations[i];\n\n                        let blockDeclaration, varName, blockVarValue;\n                        const variableName = declaration['id']; // is an Expression (Literal)\n                        const variableValue = declaration['init']; // is an Expression too\n                        console.log(\"variableName\" + i.toString() + \":\", variableName);\n                        console.log(\"variableValue\" + i.toString() + \":\", variableValue);\n\n                        // get variable name\n                        varName = variableName['name'];\n                        // get variable value (if any)\n                        try {\n                            blockVarValue = this.parseExpression(variableValue);\n                            blockDeclaration = BlockLogic.forVariableDeclaration(varName, blockVarValue);\n                        } catch {\n                            blockDeclaration = BlockLogic.forVariableDeclaration(varName);\n                        }\n                        // insert each declaration\n                        xml_statements.push(blockDeclaration);\n                    }\n\n                } else if (statementType === 'FunctionDeclaration') {\n                    // @TO-DO\n                } else if (statementType === 'ClassDeclaration') {\n                    ////////\n                }\n            }\n            console.log(line);\n        }\n        // console.log(\"xml_statements.length:\", xml_statements.length);\n        // nextify the jsx list into a single jsx\n        xml_statements = MainLogic.nextifyXmlStatementListIntoSingleBlock(xml_statements);\n        return xml_statements\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n    static parseUpdateStatement(varName, updateBy, operator) {\n\n        if (operator === \"-=\") updateBy = -updateBy; // little cheat awaiting for new neg block\n\n        const blockUpdate = BlockLogic.forEndExpression(\n            'Literal',\n            updateBy\n        );\n        // create blockStatement for variable change\n        return BlockLogic.forVariableUpdate(varName, blockUpdate);\n    }\n\n\n    static parseWhileStatement(statement) {\n        let xml_expression ;\n\n        const statementCondition = statement['test'];\n        const statementInstructions = statement['body'];\n        console.log(\"statementCondition:\", statementCondition);\n\n        const blockCondition = this.parseExpression(statementCondition);\n        const blockInstructions = this.parseAutonomousStatementInstructions(statementInstructions);\n\n        xml_expression = BlockLogic.forWhileStatement(\n            blockCondition,\n            blockInstructions\n        );\n        return xml_expression\n    }\n\n\n    static parseIfStatement(statement) {\n        let xml_expression;\n\n        let blocksConditions = [];\n        let blocksInstructions = [];\n\n        const statementCondition = statement['test'];\n        const statementConsequent = statement['consequent'];\n        blocksConditions.push(this.parseExpression(statementCondition));\n        blocksInstructions.push(this.parseAutonomousStatementInstructions(statementConsequent));\n\n        // not the final else : parse recursively on statementAlternate\n        try {\n            let statementAlternate = statement['alternate'];\n            while (statementAlternate['type'] === 'IfStatement') {\n                try {\n                    const alternateCondition = statementAlternate['test'];\n                    const alternateInstructions = statementAlternate['consequent'];\n                    blocksConditions.push(this.parseExpression(alternateCondition));\n                    blocksInstructions.push(this.parseAutonomousStatementInstructions(alternateInstructions));\n\n                    statementAlternate = statementAlternate['alternate'];\n                } catch {}\n            }\n            // final else : just get the instruction and push it\n            blocksInstructions.push(this.parseAutonomousStatementInstructions(statementAlternate));\n\n        } catch {}\n        // console.log(\"nbConditions:\", blocksConditions.length);\n        // console.log(\"nbInstructions:\", blocksInstructions.length);\n\n        xml_expression = BlockLogic.forIfStatement(\n            blocksConditions,\n            blocksInstructions\n        );\n        return xml_expression\n    }\n\n\n    static parseForStatement(statement) {\n        let xml_expression ;\n\n        const statementInit = statement['init'];\n        const statementTest = statement['test'];\n        const statementUpdate = statement['update'];\n        const statementInstructions = statement['body'];\n\n        // first, parameters\n        let varName, varInit, varTest, varUpdate;\n\n        // statementInit --> varName & varFrom\n        if (statementInit['type'] === 'VariableDeclaration') {\n            const declaration = statementInit['declarations'][0];\n            varName = declaration['id']['name'];\n            varInit = declaration['init']['value'];\n        } else if (statementInit['type'] === 'AssignmentExpression' ) {\n            varName = statementInit['left']['name'];\n            varInit = statementInit['right']['value'];\n        }\n\n        // statementTest --> varTo\n        varTest = statementTest['right']['value'];\n        const operatorTest = statementTest['operator'];\n\n        // statementUpdate --> varBy\n        if (statementUpdate['type'] === 'AssignmentExpression')\n            varUpdate = statementUpdate['right']['value'];\n        else if (statementUpdate['type'] === 'UpdateExpression')\n            varUpdate = 1;\n        const operatorUpdate = statementUpdate['operator'];\n        if (operatorUpdate.includes(\"-\")) varUpdate = -varUpdate; // works for '--' and '-='\n\n        // debugg\n        console.log(varName, varInit, varTest, varUpdate);\n\n        // then, blocks\n        let blockFrom, blockTo, blockBy, blockInstructions = [];\n\n        // instructions\n        blockInstructions.push(this.parseAutonomousStatementInstructions(statementInstructions));\n\n        // just to check logical validity\n        if (varTest >= varInit && operatorTest.includes('<') ||\n            varTest <= varInit && operatorTest.includes('>') )\n        {\n            blockFrom = BlockLogic.forEndExpression('Literal', varInit);\n            blockTo = BlockLogic.forEndExpression('Literal', varTest);\n            blockBy = BlockLogic.forEndExpression('Literal', varUpdate);\n        }\n\n        xml_expression = BlockLogic.forForStatement(\n            varName,\n            blockFrom,\n            blockTo,\n            blockBy,\n            blockInstructions\n        );\n        return xml_expression\n    }\n\n\n    static parseAutonomousStatementInstructions(statements) {\n        let xml_statement = [] ;\n\n        const statementInstructions = statements['body'];\n        console.log(\"statementInstructions:\", statementInstructions);\n\n        // recursively analyse statements of the body\n        xml_statement = this.parseListStatements(statementInstructions);\n        return xml_statement\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n    static parseExpression(expression) {\n        let xml_expression ;\n\n        const expressionType = expression['type'];\n        if (expressionType.includes('Expression'))\n            xml_expression = this.parseHostExpression(expression);\n        else\n            xml_expression = this.parseEndExpression(expression);\n\n        return xml_expression\n    }\n\n\n    static parseHostExpression(hostExpression) {\n        let xml_expression ;\n\n        const expressionType = hostExpression['type'];\n        const expressionOperator = hostExpression['operator'];\n        console.log(\"expressionType:\", expressionType);\n        console.log(\"expressionOperator:\", expressionOperator);\n\n        if (expressionType === 'UnaryExpression') {\n            // we'll create a special negate block for arithmetic later.\n            const expressionArg = hostExpression['argument'];\n\n            const blockArg = this.parseExpression(expressionArg);\n\n            xml_expression = BlockLogic.for1ArgExpression(blockArg, expressionOperator);\n\n        } else if (expressionType === 'LogicalExpression'\n                || expressionType === 'BinaryExpression') {\n            // two members : left and right\n            const expressionArgLeft = hostExpression['left'];\n            const expressionArgRight = hostExpression['right'];\n\n            const blockArgLeft = this.parseExpression(expressionArgLeft);\n            const blockArgRight = this.parseExpression(expressionArgRight);\n\n            xml_expression = BlockLogic.for2ArgsExpression(blockArgLeft, blockArgRight, expressionOperator);\n\n        } else if (expressionType === 'AssignmentExpression'\n                || expressionType === 'UpdateExpression') {\n            // these are not real expressions but statements\n            console.log(\"!!! UNEXPECTED SITUATION !!!\");\n        }\n\n        return xml_expression\n    }\n\n\n    static parseEndExpression(endExpression) {\n        let xml_expression ;\n\n        const endExpression_type = endExpression['type'];\n        let endExpression_val, attrName_valueOrName;\n\n        if (endExpression_type === 'Literal')\n            attrName_valueOrName = 'value';\n        else if (endExpression_type === 'Identifier')\n            attrName_valueOrName = 'name';\n\n        endExpression_val = endExpression[attrName_valueOrName];\n        console.log(\"endExpression:\", endExpression_type, endExpression_val);\n\n        xml_expression = BlockLogic.forEndExpression(endExpression_type, endExpression_val);\n        return xml_expression\n    }\n}","import React from 'react';\nimport jsx2str from 'jsx-to-string';\n\nimport {EsprimaToXml} from \"./EsprimaToXml\";\n\nimport {convertJsxArrayIntoStringArray} from \"../../static/methods\";\nimport {line, star} from \"../../static/constants\";\n\n\nexport class MainLogic extends React.Component {\n\n\n    static nextifyXmlStatementListIntoSingleBlock(statements) {\n\n        for (let i = statements.length - 1; i > 0; i--) {\n            let jsx_cur = statements[i];\n            let jsx_prev = statements[i - 1];\n            // console.log(\"jsx_str_cur\" + i + \":\", jsx2str(jsx_cur));\n            // console.log(\"jsx_str_prev\" + i + \":\", jsx2str(jsx_prev));\n\n            // // now insert nextified cur at the good place index in prev\n            // 1) get back previous block type\n            const blocklyType = jsx_prev.props.type;\n            const blockChildren = jsx_prev.props.children;\n            // console.log(\"test_blocklyType\", blocklyType);\n            // console.log(\"test_blockChildren\", convertJsxArrayIntoStringArray(blockChildren));\n            // 2) create again prev block with nextified current block\n            jsx_prev = <block type={blocklyType}>{\n                    blockChildren\n                }<next>{\n                    jsx_cur\n                }</next>\n            }</block>\n            // 3) insert result back into the array\n            // console.log(\"insertion done:\", jsx2str(jsx_prev));\n            statements[i - 1] = jsx_prev;\n            console.log(line);\n        }\n        return statements[0]\n    }\n\n\n    static generateBlocksFromParsedContent(parsedContent) {\n\n        const xml_main = <xml xmlns='http://www.w3.org/1999/xhtml'>{\n            // this.insertNextTagsIntoStatementList_new( // returns a single JSX\n                EsprimaToXml.parseListStatements(parsedContent)\n            // )\n        }</xml>;\n\n        // debug it stringified and return it as jsx\n        console.log(line);\n        console.log(\"xml_main (stringified) :\", jsx2str(xml_main));\n        return xml_main; // it's still a JSX\n    }\n\n}","import React from 'react';\nimport ReactDOMServer from 'react-dom/server';\nimport jsx2str from 'jsx-to-string';\n\nimport {CodeContainer} from \"./CodeContainer\";\nimport {BlocklyContainer} from \"./BlocklyContainer\";\nimport {MainLogic} from \"../parse/MainLogic\";\n\nimport {splitLineByLine} from \"../../static/methods\";\nimport {line, star} from \"../../static/constants\";\n\nconst esprima = require('esprima');\n\n\nexport class MainContainer extends React.Component {\n\n    constructor(props) {\n        super(props);\n\n        this.state = {\n            parsedContent: null,\n            xmlContent: \"\"\n        };\n\n        this.updateCode = this.updateCode.bind(this)\n    }\n\n    updateCode(event) {\n        let inputContent = event.target.value;\n\n        // processes JS <> Blockly conversion\n        try {\n            // const split_content = splitLineByLine(inputContent);\n\n            // ### VER 1 : lexical\n            // let parsedContent = this.lexicalAnalysis(codeToParse);\n            // ### VER 2 : syntaxic\n            let parsedContent = this.syntaxicAnalysis(inputContent);\n\n            console.log(star);\n            console.log(\"programBody:\", parsedContent);\n            console.log(star);\n\n            const xmlContent_jsx = MainLogic.generateBlocksFromParsedContent(parsedContent);\n            // !!! this jsx --> str conversion with ReactDOMServer.RenderToStaticMarkup\n            // !!! is ONLY for the final output (to avoid space that jsx-to-string woulg add)\n            const xmlContent_str = ReactDOMServer.renderToStaticMarkup(xmlContent_jsx);\n            // console.log(\"xmlContent_str:\", xmlContent_str);\n\n            this.setState({\n                parsedContent: parsedContent,\n                xmlContent: xmlContent_str\n            });\n\n        } catch (ex) { // this means invalid program syntax\n            ////// maybe insert lexical analysis here\n\n            this.setState({\n                parsedContent: null,\n                xmlContent: \"\" // ### Comment or uncomment to try ### Choose the one you prefer, both work :)\n            });\n        }\n    }\n\n    syntaxicAnalysis(codeRaw) {\n        // console.log(\"codeRaw: \" , codeRaw);\n\n        let codeParsed;\n        try {\n            codeParsed = esprima.parse(codeRaw);\n            return codeParsed.body\n        } catch (ex) {\n        }\n    }\n\n    lexicalAnalysis(codeRaw) {\n        // console.log(\"codeRaw: \" , codeRaw);\n\n        let codeParsed;\n        try {\n            codeParsed = esprima.tokenize(codeRaw);\n            return codeParsed\n        } catch (ex) {\n        }\n    }\n\n    render() {\n        return (\n            <div>\n                <CodeContainer\n                    exampleCode={this.exampleCode}\n                    updateCode={this.updateCode}\n                />\n                \n                <BlocklyContainer\n                    xmlContent={this.state.xmlContent}\n                />\n            </div>\n        )\n    }\n}","import React  from 'react';\nimport Blockly from 'blockly';\n\nimport './App.css';\nimport {MainContainer} from \"./components/containers/MainContainer\";\n\n\nclass App extends React.Component {\n\n    componentDidMount() {\n\n        Blockly.inject('blocklyDiv', {\n                toolbox: document.getElementById('toolbox') // comment this line to inject no toolbox\n        });\n    }\n\n\n    render() {\n        return (\n            <div className={\"main\"}>\n                <div className={\"header\"}>\n                    <h1>HEY GUYS :)</h1>\n                    <h4>Enjoy visualising horribly-indented code with this fantastic app ;)</h4>\n                </div>\n                <br></br>\n                <MainContainer className={\"main-container\"}/>\n            </div>\n        );\n    }\n}\n\nexport default App;","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}